1. G1的特点
G1 可以并发完成大部分 GC 的工作，这期间不会“Stop-The-World”。
G1 使用非连续空间，这使 G1 能够有效地处理非常大的堆。此外，G1 可以同时收集年轻代和年老代。
G1 并没有将 Java 堆分成三个空间（Eden、Survivor 和 Old），而是将堆分成许多（通常是几百个）非常小的区域。
这些区域是固定大小的（默认情况下大约为 2MB）。每个区域都分配给一个空间。
G1 将堆拆分成小的区域，一个最大的好处是可以做局部区域的垃圾回收，而不需要每次都回收整个区域比如年轻代和年老代，
这样回收的停顿时间会比较短。
E: Eden  S: Survivor  O: Old   U：未分配区域
JDK9及之后默认就采用G1了。

2. G1收集过程
将所有存活的对象将从收集的区域复制到未分配的区域，比如收集的区域是 Eden 空间，
把 Eden 中的存活对象复制到未分配区域，这个未分配区域就成了 Survivor 空间。
理想情况下，如果一个区域全是垃圾（意味着一个存活的对象都没有），则可以直接将该区域声明为“未分配”。

为了优化收集时间，G1 总是优先选择垃圾最多的区域，从而最大限度地减少后续分配和释放堆空间所需的工作量。
这也是 G1 收集器名字的由来——Garbage-First。

3. CMS
对于 CMS 收集器来说，最重要的是合理地设置年轻代和年老代的大小。年轻代太小的话，会导致频繁的 Minor GC，
并且很有可能存活期短的对象也不能被回收，GC 的效率就不高。而年老代太小的话，容纳不下从年轻代过来的新对象，
会频繁触发单线程 Full GC，导致较长时间的 GC 暂停，影响 Web 应用的响应时间。
JDK8及之后JVM会自动调整新生代和老年代，以及Eden与Srvivor的比例。因此强烈建议升级到新版本。