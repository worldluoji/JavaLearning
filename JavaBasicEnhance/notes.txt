1.  f是一个InputStream，那么BufferedReader in = new BufferedReader(new InputStreamReader(f)), 关闭时只需要in.close()，关闭最外层。
因为Java io包里的stream和reader，都是用的装饰器模式。
可以直接阅读BufferedReader源码。

2. getDeclaredFileds和getFields的区别：
getFields获取的是自身和继承而来的public属性，而getDeclaredFileds获取的是当前类的所有属性，包括private, protected, default, public.

3. a.isAssignableFrom(b)
针对两个Class类型实例a和b, 如果a对应的类信息是b对应类信息的父类或接口，或者a对应类信息和b对应类信息为同一个类或接口，则为true,否则为flase.
比如List<String> list = new ArrayList<>()
那么List.class.isAssignableFrom(list)为true

4. 二维数组排序参考：
class Solution {
    public boolean canAttendMeetings(int[][] intervals) {
        int r = intervals.length;
        if (r == 0) {
            return true;           
        }

        Arrays.sort(intervals, (int[] o1, int[] o2) -> o1[0] - o2[0]);

        for (int i = 1; i < r; i++) {
            if ( (intervals[i][0] < intervals[i-1][1]) && (intervals[i][0] >= intervals[i-1][0]) ) {
                return false;
            }
        }

        return true;
    }
}

5. JDK8数组和List相互转换
数组转化为List
 String[] arrays = new String[]{"a", "b", "c"};
 List<String> listStrings = Stream.of(arrays).collect(Collectors.toList())
这是建议的方式。Arrays.asList有坑。

List转化为数组：
1）. 使用Stream:
String[] ss = listStrings.stream().toArray(String[]::new);
这是推荐的方式。

2）. 使用List中的toArray()方法
String[] sss = listStrings.toArray(new String[listStrings.size()]);

6. 利用反射机制获取注解属性和修改注解属性值的方法：
InvocationHandler handler = Proxy.getInvocationHandler(annotation);
// 通过动态代理获取常量池中的Map memberValues字段
Field field = handler.getClass().getDeclaredField("memberValues");
// 设置字段可访问性
field.setAccessible(true);
// 获取属性注解ID的Map
Map o = (Map) field.get(handler);
// 修改属性注解ID的属性值
o.put("value", "修改成功");

7. 没有getter和setter方法，反射机制仍然可以修改属性值

8. 在1.8低版本及以下的版本中，双重锁要加volatile关键字，禁止指令重排序，否则可能小概率会出现空指针异常。
原因是编译器的优化和线程切换导致如下操作不是原子的: a.申请一块内存M->b.赋值给instance->c.初始化instance
private volatile static ActivityLifeManager instance;
public static ActivityLifeManager getInstance() {
    if (instance == null) {
        synchronized (ActivityLifeManager.class) {
            if (instance == null) {
                instance = new ActivityLifeManager();
            }
        }
    }
    return sInstance;
}
如果不加volatile, sonarcube会报：
Possible double check of field
This method may contain an instance of double-checked locking. 
This idiom is not correct according to the semantics of the Java memory model. 
For more information, see the web page.

